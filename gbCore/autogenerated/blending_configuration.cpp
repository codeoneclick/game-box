// autogenerated: do not add any changes
#include "blending_configuration.h"
namespace gb
{
bool blending_configuration::get_is_enabled(void) const
{
const auto& iterator = m_attributes.find("/blending/is_enabled");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__IS_CONFIGURATION_MUTABLE__)
void blending_configuration::set_is_enabled(bool is_enabled)
{
configuration::set_attribute("/blending/is_enabled", std::make_shared<configuration_attribute>(is_enabled));
}
#endif
ui32 blending_configuration::get_blending_function_source(void) const
{
const auto& iterator = m_attributes.find("/blending/blending_function_source");
assert(iterator != m_attributes.end());
ui32 value; iterator->second->get(&value);
return value;
}
#if defined(__IS_CONFIGURATION_MUTABLE__)
void blending_configuration::set_blending_function_source(ui32 blending_function_source)
{
configuration::set_attribute("/blending/blending_function_source", std::make_shared<configuration_attribute>(blending_function_source));
}
#endif
ui32 blending_configuration::get_blending_function_destination(void) const
{
const auto& iterator = m_attributes.find("/blending/blending_function_destination");
assert(iterator != m_attributes.end());
ui32 value; iterator->second->get(&value);
return value;
}
#if defined(__IS_CONFIGURATION_MUTABLE__)
void blending_configuration::set_blending_function_destination(ui32 blending_function_destination)
{
configuration::set_attribute("/blending/blending_function_destination", std::make_shared<configuration_attribute>(blending_function_destination));
}
#endif
ui32 blending_configuration::get_blending_equation(void) const
{
const auto& iterator = m_attributes.find("/blending/blending_equation");
assert(iterator != m_attributes.end());
ui32 value; iterator->second->get(&value);
return value;
}
#if defined(__IS_CONFIGURATION_MUTABLE__)
void blending_configuration::set_blending_equation(ui32 blending_equation)
{
configuration::set_attribute("/blending/blending_equation", std::make_shared<configuration_attribute>(blending_equation));
}
#endif
ui32 blending_configuration::get_attachment_index(void) const
{
const auto& iterator = m_attributes.find("/blending/attachment_index");
assert(iterator != m_attributes.end());
ui32 value; iterator->second->get(&value);
return value;
}
#if defined(__IS_CONFIGURATION_MUTABLE__)
void blending_configuration::set_attachment_index(ui32 attachment_index)
{
configuration::set_attribute("/blending/attachment_index", std::make_shared<configuration_attribute>(attachment_index));
}
#endif
void blending_configuration::serialize_xml(pugi::xml_document& document, const std::string& path)
{
pugi::xpath_node node;
node = document.select_single_node((path + "/blending").c_str());
bool is_enabled = node.node().attribute("is_enabled").as_bool();
configuration::set_attribute("/blending/is_enabled", std::make_shared<configuration_attribute>(is_enabled));
std::string blending_function_source = node.node().attribute("blending_function_source").as_string();
assert(g_string_to_glenum.find(blending_function_source) != g_string_to_glenum.end());
ui32 blending_function_source_enum = g_string_to_glenum.find(blending_function_source)->second;
configuration::set_attribute("/blending/blending_function_source", std::make_shared<configuration_attribute>(blending_function_source_enum));
std::string blending_function_destination = node.node().attribute("blending_function_destination").as_string();
assert(g_string_to_glenum.find(blending_function_destination) != g_string_to_glenum.end());
ui32 blending_function_destination_enum = g_string_to_glenum.find(blending_function_destination)->second;
configuration::set_attribute("/blending/blending_function_destination", std::make_shared<configuration_attribute>(blending_function_destination_enum));
std::string blending_equation = node.node().attribute("blending_equation").as_string();
assert(g_string_to_glenum.find(blending_equation) != g_string_to_glenum.end());
ui32 blending_equation_enum = g_string_to_glenum.find(blending_equation)->second;
configuration::set_attribute("/blending/blending_equation", std::make_shared<configuration_attribute>(blending_equation_enum));
ui32 attachment_index = node.node().attribute("attachment_index").as_uint();
configuration::set_attribute("/blending/attachment_index", std::make_shared<configuration_attribute>(attachment_index));
}
void blending_configuration::serialize_json(Json::Value& json)
{
bool is_enabled = json.get("is_enabled", false).asBool();
configuration::set_attribute("/blending/is_enabled", std::make_shared<configuration_attribute>(is_enabled));
std::string blending_function_source = json.get("blending_function_source", "unknown").asString();
assert(g_string_to_glenum.find(blending_function_source) != g_string_to_glenum.end());
ui32 blending_function_source_enum = g_string_to_glenum.find(blending_function_source)->second;
configuration::set_attribute("/blending/blending_function_source", std::make_shared<configuration_attribute>(blending_function_source_enum));
std::string blending_function_destination = json.get("blending_function_destination", "unknown").asString();
assert(g_string_to_glenum.find(blending_function_destination) != g_string_to_glenum.end());
ui32 blending_function_destination_enum = g_string_to_glenum.find(blending_function_destination)->second;
configuration::set_attribute("/blending/blending_function_destination", std::make_shared<configuration_attribute>(blending_function_destination_enum));
std::string blending_equation = json.get("blending_equation", "unknown").asString();
assert(g_string_to_glenum.find(blending_equation) != g_string_to_glenum.end());
ui32 blending_equation_enum = g_string_to_glenum.find(blending_equation)->second;
configuration::set_attribute("/blending/blending_equation", std::make_shared<configuration_attribute>(blending_equation_enum));
ui32 attachment_index = json.get("attachment_index", 0).asUInt();
configuration::set_attribute("/blending/attachment_index", std::make_shared<configuration_attribute>(attachment_index));
}
void blending_configuration::serialize_xml(pugi::xml_document& document, pugi::xpath_node& node)
{
bool is_enabled = node.node().attribute("is_enabled").as_bool();
configuration::set_attribute("/blending/is_enabled", std::make_shared<configuration_attribute>(is_enabled));
std::string blending_function_source = node.node().attribute("blending_function_source").as_string();
assert(g_string_to_glenum.find(blending_function_source) != g_string_to_glenum.end());
ui32 blending_function_source_enum = g_string_to_glenum.find(blending_function_source)->second;
configuration::set_attribute("/blending/blending_function_source", std::make_shared<configuration_attribute>(blending_function_source_enum));
std::string blending_function_destination = node.node().attribute("blending_function_destination").as_string();
assert(g_string_to_glenum.find(blending_function_destination) != g_string_to_glenum.end());
ui32 blending_function_destination_enum = g_string_to_glenum.find(blending_function_destination)->second;
configuration::set_attribute("/blending/blending_function_destination", std::make_shared<configuration_attribute>(blending_function_destination_enum));
std::string blending_equation = node.node().attribute("blending_equation").as_string();
assert(g_string_to_glenum.find(blending_equation) != g_string_to_glenum.end());
ui32 blending_equation_enum = g_string_to_glenum.find(blending_equation)->second;
configuration::set_attribute("/blending/blending_equation", std::make_shared<configuration_attribute>(blending_equation_enum));
ui32 attachment_index = node.node().attribute("attachment_index").as_uint();
configuration::set_attribute("/blending/attachment_index", std::make_shared<configuration_attribute>(attachment_index));
}
}
